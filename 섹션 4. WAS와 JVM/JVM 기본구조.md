# Machine과 VM

## CPU(Machine)

- CPU가 인식할 수 있는 코드를 Machine code라고 부름 (프로세서마다 구체적인 값은 다름)
- 네이티브 코드는 컴파일러가 머신코드에 대고 번역
- 하이레벨 언어의 코드를 CPU가 인식할 수 있는 기계어로 바꿈
- 이러한 커널단을 플랫폼이라고 함

## JVM

- 컴퓨터 = CPU + RAM + SSD
- JVM = OS + 프로세서 + 메모리
- 자바 바이트 코드를 실행해주는 인터프리터를 포함하고 있는 논리적인 머신

# JVM 구성요소

![image](https://github.com/user-attachments/assets/ac264db8-d480-4d37-b1d1-351550e3e82f)


크게 4가지로 이루어짐

### Class Loader

클래스 로딩, 링킹, 초기화해서 실질적인 실행으로 넘김

### Execution Engine

- 자바 바이트 코드를 인터프리터함
- 그걸 실행으로 가져가서 JIT 컴파일러로 실행
- 경우에 따라서는 네이티브 코드로 변환해서 빠른 처리가 되도록 해줌

*인터프리터: 고급 언어로 작성된 코드를 한 줄씩 읽어드려 실행하는 프로그램

*JIT 컴파일러: 프로그램을 실제 실행하는 시점에서 기계어로 번역하는 컴파일 기법

- JIT 컴파일러는 정적 컴파일 방식과 인터프리트 방식을 혼합한 방식으로 생각할 수 있다.

- 자바의 경우 다음 순서를 거친다.
    1. 자바 컴파일러가 자바 소스 코드를 바이트 코드로 변환하며 최적화한다.
    2. 바이트 코드가 실행되는 과정에서 실시간으로 JIT컴파일러가 바이트 코드를 기계어로 변환한다.
        - 실행되는, 즉 필요한 부분만 변환된다.
        - 변환된 기계어 코드는 캐싱되어 다시 컴파일할 필요가 없다.
        

### JIT의 장점

- 기존의 방식들보다 나은 점: *실행 과정에서 필요한만큼만 컴파일한다!*
    - 인터프리트 방식은 소스코드를 최적화 과정이 없이 번역하기 때문에 성능이 낮음
    - 정적 컴파일언어는 실행 전에 무조건 컴파일을 했기 때문에, 다양한 플랫폼에 맞게 컴파일을 하기 위해 많은 시간 소요
- 보통 인터프리터에 비해 빠른 수준이며, 경우에 따라 정적 컴파일러보다 빠르기도 함.

![image (1)](https://github.com/user-attachments/assets/8f4cc5aa-7c93-4116-8403-67b977280563)


출처: [컴파일러와-인터프리터-그리고-JIT-컴파일](https://velog.io/@bcj0114/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EC%99%80-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%EA%B7%B8%EB%A6%AC%EA%B3%A0-JIT-%EC%BB%B4%ED%8C%8C%EC%9D%BC)

실행 = 연산, 연산과정에서 각종 메모리 영역을 쓰게 됨

## Stack

JVM은 Stack based 머신으로 구현이 되어있음

### ex)

- 메소드 함수가 하나 있으면 누구를 호출하는지 콜 그래프가 그려짐
- 호출관계가 계속 이어지는데 이걸 스택으로 쌓아서 나타냄
- JVM에서는 네이티브 코드와 달리 배열의 형태로 구현되어 있음

### Stack + 자동

- 함수를 콜하게 되면 괄호가 열리고 리턴하면서 닫힘
    - 그 사이에 지역변수 선언해서 메모리를 사용
    - 자료형에 대해서 기본형, 참조형이 있는 있음
        - 참조형은 실체의 메모리가 있는게 아니고 참조자만 있고 가리키는 대상은 어딘가에 따로 존재
    - 이게 관리되는 위치가 Heap 영역

## PC(Program Counter) Register

각각의 쓰레드마다 PC Register라고 실행코드가 있으면, 그 코드가 어디서 작동중인지 관리하는 역할을 수행

### ex)

명령어가

1. ~
2. ~
3. ~

이런식으로 있는 경우 2번 명령어를 수행하면 다음은 3번

# JVM Runtime data area

## Heap area

- 메모리를 사용할 때 가장 많은 부분을 차지하는게 힙 영역
- 자바 백엔드 개발 → HTTP 베이스
    - 바이너리 데이터도 있지만 Base64 인코딩이 되어있는 아스키 문자열 형태로 정보를 다룰 때가 많음
    - 문자열 데이터들이 생각보다 용량이 크기 때문에 처리과정에서 힙영역을 많이 사용
- 멀티 쓰레드를 쓰게 되면 그에 따른 부하도 넘어가게 됨

## 구조를 이해해야 하는 이유

- 자바는 가비지 컬렉터가 있음
    - new ( ) 연산을 통해서 어떤 인스턴스를 생성하면 메모리를 사용하게 됨
    - 그 메모리가 힙영역에서 생겨나게 됨
    - 이렇게 생기는 메모리의 사용을 개발자는 전혀 관리하지 않음 ⇒ 가비지 컬렉터가 관리
- 하지만 힙영역의 관리 구조는 이해하고 있는 것이 좋음
    - 구조적인 문제로 어떠한 현상이 발생할 수 있기 때문에 (장애가 발생한다던가)
    - 가비지 컬렉터가 알아서 해주기 때문에 표면적으로 드러나지 않는 장애, 에러가 생길 수 있음
- 뛰어난 실무 개발자는 이러한 예상될만한 문제들을 처음부터 발생하지 않도록 개발해야 한다
    - 운영을 감안해서 개발하고 있다는 모습을 보여줘야 함
