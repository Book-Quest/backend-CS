# 인덱싱을 하는 이유

## 테이블에 대한 **검색 속도**를 높이기 위해 생성하며 **컬럼에 적용**

ex) 주소록 - 이름(PK), 전화, 주소

→ 자주 검색하게 되는 컬럼에 인덱스를 설정해주게 되면 검색 속도가 올라감

## 주로 **B-Tree 혹은 B+Tree** 자료구조로 구현되는 것이 일반적

### B-Tree

- 인덱스노드라고 정보가 같이 남아있음
- B+Tree 보다 속도가 조금 더 빠름, 추가, 삭제하기가 용이

### B+Tree

- 인덱스 검색 속도는 B-Tree보다 빠름
- 수정, 삭제가 별로 없으면 B+Tree로 인덱스를 거는게 더 나을 수도 있음

---

### B-Tree란?

![image](https://github.com/user-attachments/assets/d88fde3f-31eb-41bf-8985-a1adbde19a9c)

- 이진트리와 유사하지만, 한 노드 당 자식 노드를 2개 이상 가지는 것이 가능
- key값을 이용해 찾고자 하는 데이터를 트리 구조를 이용해 찾는 것
- 균형 트리로 루트로부터 리프(자식노드)까지의 거리가 일정한 트리 구조
- 하지만 INSERT, UPDATE, DELETE를 반복하면 균형도 꺠지고 성능도 악회됨

![image (1)](https://github.com/user-attachments/assets/1809c775-a53a-4c7c-84ac-792a206261e4)


인덱스를 사용하면 데이터양에 비례해서 효과가 상승함

### B+Tree란?

![image (2)](https://github.com/user-attachments/assets/5b4dcc0b-8160-43b0-96c0-bd65d9b64fcc)

- B-Tree의 확장 개념. B-Tree는 노드에 key, data를 담을 수 있으나 B+Tree는 key만 담아두고 data는 담지 않음
- 리프 노드에만 key, data를 저장하고 리프 노드끼리 Linked list로 연결되어 있음

### B+Tree 장점

- 리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리를 더 확보함으로써 더 많은 key를 수용
- 하나의 노드에 더 많은 key를 담을 수 있기 때문에 트리의 높이는 더 낮아짐(cache hit를 높일 수 있음)

### **Cache hit(캐시 히트)**

**CPU가 원하는 데이터를 캐시에서 성공적으로 찾는 것**

### **캐시(Cache)란?**

캐시는 CPU가 자주 사용하는 데이터를 미리 저장해 두는 고속 메모리야.

보통 **CPU가 데이터를 찾을 때 1차적으로 캐시에서 검색하고, 캐시에 없으면 메인 메모리(RAM)에서 가져옴**.

### **Cache hit가 중요한 이유**

- 캐시에서 데이터를 찾으면(=Cache hit) **CPU가 빠르게 접근**할 수 있음.
- 반대로, 캐시에 데이터가 없으면(=Cache miss) **느린 메모리(RAM)에서 가져와야 해서 성능 저하**가 발생함.

### **트리의 높이와 Cache hit의 관계**

비+트리(B+Tree)는 한 노드에 여러 개의 Key를 저장할 수 있어서 **트리의 높이가 낮아짐**.

- 즉, 데이터를 찾을 때 **메모리 접근 횟수가 줄어듦** → **캐시에서 데이터를 찾을 확률(Cache hit rate)이 증가**함.
- 결과적으로, **CPU가 데이터를 빠르게 찾을 수 있어 성능이 향상됨**.

### B-Tree VS B+Tree

<img width="778" alt="image (3)" src="https://github.com/user-attachments/assets/91a8109b-7817-4119-a610-037e7b48479d" />


출처: [[MySQL] B-tree, B+tree란? (인덱스와 연관지어서)](https://zorba91.tistory.com/293)

---

### 대규모 테이블에 대해 적용하며 **삽입, 수정, 삭제가 자주 발생하지 않는 경우**에 활용

- 대규모라고 하려면 최소 데이터가 10만건은 있어야 함. 그래서 1억건 정도로 개수만 늘려서 처리해보기.
- 건수에 따라서 쿼리 응답 속도가 느려짐
- 인덱스를 걸어서 더 빠르게 응답이 나오게 해야함
    - 인덱스가 있을 경우 **검색속도 증가**
    - 테이블에 **없는 정보 검색 시 빠른 판단**이 가능

### 인덱스 탐색 예시

- 데이터 저장을 파일의 형태로 2차 메모리에 함
- 파일 메모리는 연속된, 플랫한, 시퀀셜한 메모리

**ex)** 

5 7 1 3 9 2…

- 선형구조의 데이터가 있을때, 없는 정보를 검색했을때 Worst case 발생 (전부 다 탐색해야하므로)
- 이런 경우 인덱스를 생성해 놓으면 검색속도가 올라감. (없는 정보를 더 빠르게 알아낼 수 있기 때문에)

### 이진트리로 인덱스 탐색 원리 설명

**ex)** 

5 7 1 3 9 2… ****

- 이런 경우에 5가 root라고 치면 그 다음에 오는 노드값을 크기에 따라서 왼쪽, 오른쪽으로 나눠서 분류
- 그럼 여기서 11을 찾는다면 루트 5에서 시작해서 5 - 7 - 9 순으로 3번의 탐색만에 11이 없다는 것을 알 수 있음.
- 이진트리 같은 분류 체계를 B-Tree, B+Tree 구조로 데이터 구조를 만들어서 이진트리가 가지고 있는 문제점을 해결해놓은 구조

## 인덱싱에 따른 오버헤드

인덱스는 이처럼 질의시 성능이 좋지만, 인덱싱에 따른 오버헤드가 존재

- 인덱스를 위한 **메모리 추가 소모**
- 데이터 삭제, 수정시 **인덱스까지 수정**해야 하는 오버헤드

> **데이터의 수정으로 인해서 인덱스를 다시 계산해야 하는 경우가 생길 수 있으므로 그런 경우에는 느려지고, 오버헤드도 발생**
> 

### 인덱싱의 장단점

- 장점: 정보 검색, 읽기가 빠르다
- 단점: 원하는 것을 찾을때, 그게 갱신될때 오버헤드가 있을 수 있다
