# OS: User mode와 Kernel mode

## HW(피지컬 계층의 전산 자원)

### 컴퓨터란? CPU + RAM + SSD

- CPU(연산을 할 수 있는 전자계산기)
- RAM(주 기억장치, 1차메모리)
- SSD(HDD, 2차 메모리)

2차 메모리에서 가져와서 → RAM메모리에서 버퍼링했다가 → CPU에 전달해서 연산

## User mode

어플리케이션 프로세스

프로세스가 여러개 → 멀티태스킹 환경

⇒ 커널에서 제어가 필요, 동시에 작용하기 때문에

## Kernel mode

### Kernel이란?

OS의 핵심 알맹이, 입출력이나 각종 운영체제로서의 제어체제를 갖춤

멀티스레드 환경에서 제어체계, 동기화 (운영체제가 역할 수행)

### Platform

- OS부터 HW까지를 칭함 ex) Windows, Linux
- 운영체제 + 하드웨어 + 메모리 체계

### Native code

- 플랫폼에 의존적인 언어의 경우(CPU or OS 등)를 Native code라고 부름
- 1,2차 메모리를 한군데로 묶어서 운영체제 수준에서는 가상메모리로 관리
- 네이티브 언어(C/C++)개발자들은 이러한 특성을 고려해서 개발함

### 32, 64bit

- CPU가 64비트를 사용한다면? 64비트 플랫폼이라고 말함
- 어플리케이션 프로세스도 32, 64비트가 있음
- 64비트 플랫폼에서는 32, 64비트 어플리케이션 모두 잘 작동
- 하지만 32비트 플랫폼에서는 64비트 어플리케이션을 작동시키는데는 어려움이 있음

---

| 구분 | 32비트 CPU | 64비트 CPU |
| --- | --- | --- |
| **데이터 처리량** | 한 번에 32비트(4바이트) 처리 | 한 번에 64비트(8바이트) 처리 |
| **메모리 접근 범위** | 최대 4GB (2³² = 약 4GB) | 16엑사바이트 (2⁶⁴ = 이론상 16EB) |
| **프로세서 성능** | 상대적으로 낮음 | 더 많은 연산 가능 |
| **운영체제 지원** | 32비트 OS만 사용 가능 | 32비트, 64비트 OS 사용 가능 |
| **프로그램 호환성** | 32비트 프로그램만 실행 가능 | 32비트 및 64비트 프로그램 실행 가능 |

---

### Java

네이티브 코드 X, Managed Code

머신에 의존하지 않고 다른 곳에 의존해서 작동

# Machine과 VM

머신코드: CPU가 인식할 수 있는 코드

머신 수준에 의존성이 있으면 Native code

## JVM

### Big endian system

엔디언: 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법

→ 이 배열 방법을 바이트 순서라고 함

큰 단위가 앞에 나오는 **빅 엔디언** vs 작은단위가 앞에 나오는 **리틀 엔디언**으로 나뉨

 

- **빅 엔디언 (Big-Endian)**
    - 네트워크 통신에서 사용되는 정렬 방식이다.
    - 상위 바이트(high byte)가 메모리에 먼저 기록되는 방식이다.
    - 스택에서 PUSH될 때 맨 앞(메모리 주소가 낮은)에서부터 진행된다.
    - 사용자가 눈으로 보기 편하기 때문에 디버그 환경에 적합하다.
    - 비교 연산에서 Little-Endian보다 빠르다.

출처: [**Little Endian과 Big Endian**](https://devjh.tistory.com/22)

### JVM: OS + Memory + CPU

- 가상머신 자체는 HW에 의존성이 있음(네이티브로 개발됨)
- 자바개발자들은 하이레벨 언어로 개발하게 되면 자바 바이트 코드로 변환이 되어 컴파일이됨
- 컴파일된 자바 바이트코드가 JVM에서 실행

### 자바 비동기 개념(Non-blocking I/O)

- 동기로 처리하면 입출력 처리하는 동안에 대기해야함
- 비동기로는 입출력의 주체인 JVM이나 라이브러리가 처리
- 프로세스 자체가 block이 되지 않고 다음으로 넘어가서 비동기적 입출력처리

# 비동기 입/출력

- 멀티스레딩과 비동기 입출력은 동떨어진 개념
- 처리 주체에 넘겨서 어플리케이션에서 블록되는 것을 막기 위한 것

### 프로세스란?

입출력을 수행하는 주체

**네이티브 기준 ex)** 

1. Chrome.exe를 실행하면 프로세스가 하나 생겨서 작동
2. User ↔ Kernel간에 입출력하면서 커널에 넘기고 작동이 일어남(네트워크 통신)
3. 커널의 추상화된 인터페이스가 User mode에 File형태로 제공

**Socket: 네트워크 프로토콜을 추상화하는 파일**

소켓에 정보를 write할때는 **send**라고함, read는 **receive** (이게 소켓에서의 파일 입출력)

**만약 write할때 1초정도 걸리는 데이터가 있다면?**

- 동기 입출력: write 시도 후 1초가 지나서 return, 그다음으로 넘어감
- 비동기 입출력은 1초 걸릴 작업을 그냥 OS에게 떠넘겨서 입출력 시키고 프로세스 다음 작업수행

### 비동기란?

- 입출력의 실질적 처리 주체인 OS에게 넘기고 넘어가기
- 입출력이 완료될때까지 기다리는게 아니라 그냥 맡기고 다른 할일 하러 가는 것
